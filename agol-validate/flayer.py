'''
flayer.py: Lay bare all our feature layers and fix any problems

For each feature layer, check:
    > Tags
    > Group & Folder (?)
    > Delete Protection
    > Downloads enabled
    > Title against metatable

'''



import arcgis

import getpass
import datetime
import csv
import logging
import pandas as pd


def usage_sum(df):
    '''
    QnD sum of the 'Usage' series in a data frame
    '''
    return df['Usage'].sum()


def item_info(item, folder):
    '''
    Given an item object and a string representing the name of the folder it
    resides in, item_info builds a dictionary containing pertinent info about
    that item.
    '''
    item_dict = {}
    item_dict['itemid'] = item.itemid
    item_dict['title'] = item.title
    item_dict['owner'] = item.owner
    if folder:
        item_dict['folder'] = folder
    else:
        item_dict['folder'] = '_root'
    item_dict['views'] = item.numViews
    item_dict['modified'] = datetime.datetime.fromtimestamp(item.modified/1000).strftime('%Y-%m-%d %H:%M:%S')
    item_dict['authoritative'] = item.content_status
    
    #: Sometimes we get a permission denied error on group listing, so we wrap
    #: it in a try/except to keep moving
    item_dict['open_data'] = 'no'
    try:
        gnames = []
        for g in item.shared_with['groups']:
            gnames.append(g.title)
            if 'Utah SGID' in g.title:
                item_dict['open_data'] = 'yes'
        groups = ', '.join(gnames)
    except:
        groups = 'error'
        item_dict['open_data'] = 'unknown'
    item_dict['groups'] = groups
    
    tag_list = []
    for t in item.tags:
        tag_list.append(t)
    item_dict['tags'] = ', '.join(tag_list)
    mb = item.size/1024/1024
    item_dict['sizeMB'] = mb
    item_dict['credits'] = mb*.24
    
    #: Sometimes data usage also gives an error, so try/except that as well
    try:
        item_dict['data_requests_1Y'] = usage_sum(item.usage('1Y'))
    except:
        item_dict['data_requests_1Y'] = 'error'

    return item_dict


def dict_writer(dictionary, out_path):
    with open(out_path, 'w', newline='') as out_file:
        writer = csv.writer(out_file)
        for key in dictionary:
            row = [key]
            row.extend(dictionary[key])
            writer.writerow(row)


class org:

    #: A dictionary of tags and a list of items that are tagged thus
    #: {tag:[item1, item2, ...]}
    tags_and_items = {}

    #: A list of tags sorted alphabetically
    sorted_tags = []

    #: A list of dictionaries that hold info about each item. As all 
    #: dictionaries from item_info() will have the same keys, this list of
    #: dictionaries can easily be converted to a pandas dataframe.
    feature_services = []

    #: A list of feature service item objects generated by trawling all of 
    #: the user's folders
    feature_service_items = []


    def __init__(self, path, user_name):
        logging.info('==========')
        logging.info('Portal: {}'.format(path))
        logging.info('User: {}'.format(user_name))
        logging.info('==========')

        self.user_name = user_name
        self.gis = arcgis.gis.GIS(path, user_name,
                       getpass.getpass("{}'s password: ".format(user_name)))

        #: Get all the Feature Service item objects in the user's folders
        user_item = self.gis.users.get(self.user_name)

        #: Build list of folders. 'None' gives us the root folder.
        print('Getting {}\'s folders...'.format(self.user_name))
        folders = [None]
        for folder in user_item.folders:
            folders.append(folder['title'])

        #: Get info for every item in every folder
        print('Getting item objects...')
        for folder in folders:
            for item in user_item.items(folder, 1000):
                if item.type == 'Feature Service':
                    self.feature_service_items.append(item)


    def get_tags(self, method='owner', out_path=None):
        '''
        Creates a dictionary of all the tags associated with Feature Services 
        owned by user_name and the Feature Services that are tagged with them,
        {tag:[item1, item2, ...]}
        '''

        if method == 'owner':
            items = self.gis.content.search(query='owner:'+self.user_name, 
                                            item_type='Feature Layer', 
                                            max_items=1000)

            #: Create dictionary of tags and a list of items that are tagged thus
            print('Creating list of tags and the items associated with them...')
            for item in items:
                for tag in item.tags:
                    if not tag in self.tags_and_items:
                        self.tags_and_items[tag] = [item.title]
                    else:
                        self.tags_and_items[tag].append(item.title)

        elif method == 'folder':
            for item in self.feature_service_items:
                for tag in item.tags:
                    if not tag in self.tags_and_items:
                        self.tags_and_items[tag] = [item.title]
                    else:
                        self.tags_and_items[tag].append(item.title)


        #: For sanity's sake (this is in sigmund, after all), sort by name
        self.sorted_tags = sorted(self.tags_and_items)

        length_dict = {}
        for key in self.tags_and_items:
            length_dict[key] = [len(self.tags_and_items[key])]
            length_dict[key].extend(sorted(self.tags_and_items[key]))

        if out_path:
            dict_writer(length_dict, out_path)


    def tag_cloud(self, out_path=None):
        '''
        Create a list of all tags in self.feature_services
        '''

        tags = []
        for item in self.feature_service_items:
            for tag in item.tags:
                if tag not in tags:
                    tags.append(tag)

        # print(sorted(tags))
        tag_series = pd.Series(sorted(tags))
        print(tag_series)
        if out_path:
            tag_series.to_excel(out_path)


    def bad_spaces(self, out_path=None):
        '''
        Create a dictionary of items with spaced tags and a list of all their
        spaced tags {item:[bad_tag1, bad_tag2, ...]} and write it as a csv
        to out_path.
        '''

        print('Saving items with spaced tags to {}...'.format(out_path))
        space_tagged = {}
        for tag in self.tags_and_items:
            if tag.startswith(' '):
                for item_name in self.tags_and_items[tag]:
                    if item_name not in space_tagged:
                        space_tagged[item_name] = [tag]
                    else:
                        space_tagged[item_name].append(tag)

        if out_path:
            dict_writer(space_tagged, out_path)


    def duplicate_tags(self, out_path=None):

        #: Dictionary of lower-cased tag and all other tags that match when 
        #: lower-cased
        dupe_tags = {}

        #: List of all lower-cased tags
        cleaned_tags = []

        #: 
        for tag in self.tags_and_items:
            cleaned_tag = tag.lower()
            if cleaned_tag not in cleaned_tags:
                cleaned_tags.append(cleaned_tag)

        for cleaned_tag in cleaned_tags:
            for search_tag in self.tags_and_items:
                if cleaned_tag == search_tag.lower():
                    if cleaned_tag in dupe_tags:
                        dupe_tags[cleaned_tag].append(search_tag)
                    else:
                        dupe_tags[cleaned_tag] = [search_tag]

        if out_path:
            dict_writer(dupe_tags, out_path)


    def tag_fixer(self):
        '''
        Automagically fix tags with spaces, certain capitalized tags, and 
        redundant tags.
        '''

        print('\nEvaluating services\' tags...')
        logging.info('==========')
        logging.info('Fixing tags...')
        failed_group_items = []
        total = len(self.feature_service_items)
        counter = 0
        updated = 0
        for item in self.feature_service_items:
            counter += 1

            orig_tags = [t.strip() for t in item.tags]

            new_tags = []
            for orig_tag in orig_tags:

                #: single-word tag in title
                single_word_tag_not_in_title = True
                if orig_tag in item.title.split():
                    single_word_tag_not_in_title = False
                #: mutli-word tag in title
                multi_word_tag_not_in_title = True
                if ' ' in orig_tag and orig_tag in item.title:
                    multi_word_tag_not_in_title = False

                cleaned_tag = orig_tag.lower()
                #: Upercases: SGID and AGRC
                if cleaned_tag == 'sgid':
                    new_tags.append('SGID')
                elif cleaned_tag == 'agrc':
                    new_tags.append('AGRC')
                #: Fix/keep 'Utah' if it's not in the title
                elif cleaned_tag == 'utah' and orig_tag not in item.title.split():
                    new_tags.append('Utah')
                #: Don't add to new_tags if it should be deleted
                elif cleaned_tag in ['.sd', 'service definition']:
                    pass
                #: Finally, keep the tag unless it's in the title
                elif single_word_tag_not_in_title and multi_word_tag_not_in_title:
                    new_tags.append(orig_tag)
            
            #: Add the category tag
            groups = []
            try:
                for g in item.shared_with['groups']:
                    groups.append(g.title)
            except:
                failed_group_items.append(item.title)

            for group in groups:
                if 'Utah SGID' in group:
                    category = group.split()[-1]
                    #: If there's already a lowercase category tag, replace it
                    if category.lower() in new_tags:
                        new_tags.remove(category.lower())
                        new_tags.append(category)
                    elif category not in new_tags:
                        new_tags.append(category)
                    #: Make sure it's got SGID in it's tags
                    if 'SGID' not in new_tags:
                        new_tags.append('SGID')
            
            #: Only update if the tags have changed
            if sorted(item.tags) != sorted(new_tags):
                #: Update the item
                print('\nUpdating {} ({} of {})'.format(item.title, counter, total))
                print('Old tags: {}'.format(item.tags))
                print('New tags: {}'.format(new_tags))
                logging.info('Old tags <{}>: {}'.format(item.title, item.tags))
                logging.info('New tags <{}>: {}'.format(item.title, new_tags))
                item.update({'tags':new_tags})
                updated += 1
            else:
                print('\nNot updating {} — Tags are the same ({} of {})'.format(item.title, counter, total))
                print('Old tags: {}'.format(item.tags))
                print('New tags: {}'.format(new_tags))
                logging.info('Old tags <{}>: {}'.format(item.title, item.tags))
                logging.info('New tags <{}>: {}'.format(item.title, new_tags))

        print('\nUpdated {} of {} items'.format(updated, total))
        if failed_group_items:
            print('Could not determine group of: {}'.format(failed_group_items))
        logging.info('')
        logging.info('Updated {} of {} items'.format(updated, total))
        if failed_group_items:
            logging.info('Could not determine group of: {}'.format(failed_group_items))
        logging.info('==========')


    def get_feature_services_info(self, out_path=None):
        '''
        Creates a list of dictionaries holding information about each Feature 
        Service in every folder in an AGOL account and saves the list to an
        excel file.
        '''

        print('Creating item information...')
        user_item = self.gis.users.get(self.user_name)

        #: Build list of folders. 'None' gives us the root folder.
        folders = [None]
        for folder in user_item.folders:
            folders.append(folder['title'])

        #: Get info for every item in every folder
        for folder in folders:
            for item in user_item.items(folder, 1000):
                if item.type == 'Feature Service':
                    print(item.title)
                    self.feature_services.append(item_info(item, folder))
        
        #: Make a dataframe with properly ordered column names (dictionaries 
        #: are unordered) and then save that as an excel file.
        items_df = pd.DataFrame.from_records(self.feature_services, columns = [
                    'title', 'itemid', 'owner', 'folder', 'groups', 'tags',
                    'authoritative', 'modified', 'views', 'sizeMB', 'credits',
                    'data_requests_1Y', 'open_data'])
        if out_path:
            items_df.to_excel(out_path)


if __name__ == '__main__':
    logfile = r'c:\temp\agol_tag_log.txt'
    # logfile = None
    if logfile:
        logging.basicConfig(filename=logfile, level=logging.INFO)
    now = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    logging.info('')
    logging.info('Start: {}'.format(now))

    spaces_out = r'c:\temp\agol_spaced.csv'
    items_out = r'c:\temp\agol_layers_postshelf.xls'
    tags_out = r'c:\temp\agol_tags.xls'
    tags_items_out = r'c:\temp\agol_tags_items.csv'
    agrc = org('https://www.arcgis.com', 'UtahAGRC')
    # agrc.get_tags('folder', tags_out)
    # agrc.bad_spaces(spaces_out)
    agrc.get_feature_services_info(items_out)
    # agrc.tag_cloud()
    # agrc.tag_fixer()

